---
title: "Estimation of Graphical Models Using Lasso-Related Approaches"
author: "Bowen Deng"
date: "08/11/2019"
output:
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r package, include=FALSE}
library(MASS) #mvrnorm
library(glmnet) #lasso
library(glasso)

source("functions.R") #import own functions
```

## 1 Generate Samples
***

```{r}
set.seed(666)
# number of random variables
p <- 50
# number of samples generated
n <- 1000
# delta to construct Theta Matrix
delta <- 3

data <- generate(p, n, delta)

data$Theta[1:9,1:9] # part of the Theta Matrix
table(data$E_true[,3]) # corresponding true E set, 3rd column indicate whether the edge is included, table gives summary
```

## 2 Estimation
***
### 2.1 Node-wise Lasso Approach
```{r}
pred.nodewise <- predict.nodewise(data$X, lambda = 0.05)

table(pred.nodewise$E_1[,3], data$E_true[,3]) # compare estimation E_1 and true set E_true
table(pred.nodewise$E_2[,3], data$E_true[,3]) # compare estimation E_2 and true set E_true
```

### 2.2 Graphical Lasso Approach
```{r}
pred.glasso <- predict.glasso(data$X, lambda = 0.05)

table(pred.glasso$E[,3], data$E_true[,3]) # compare estimation E_3 and true set E_true
```

## 3 ROC Curve and Overall Performance
***
To produce a ROC curve, a grid of lambda is needed.
```{r}
len_grid <- 50
grid <- 10 ^ seq(1,-5, length = len_grid)
```

Run nodewise lasso over the grid. For this data, It took more than 10 secs.
```{r}
start_time <- Sys.time()

perf.nodewise <- performance.nodewise.grid(data$X, data$E_true, grid)

end_time <- Sys.time()
end_time - start_time
```

Run graphical lasso over the grid. For this data, It took less than 1 secs. Glasso is much faster.
```{r}
start_time <- Sys.time()

perf.glasso <- performance.glasso.grid(data$X, data$E_true, grid)

end_time <- Sys.time()
end_time - start_time
```

```{r, fig.height = 3, fig.width = 9, fig.align = "center"}
par(mfrow=c(1,3))
plot.roc(perf.nodewise$tpr_1, perf.nodewise$fpr_1, "ROC Curve of Approach 1")
plot.roc(perf.nodewise$tpr_2, perf.nodewise$fpr_2, "ROC Curve of Approach 2")
plot.roc(perf.glasso$tpr, perf.glasso$fpr, "ROC Curve of Graphical Lasso")
```

```{r, results='hold'}
cat("AUC for method 1: ", perf.nodewise$auc_1, "\n")
cat("AUC for method 2: ", perf.nodewise$auc_2, "\n")
cat("AUC for method 3: ", perf.glasso$auc, "\n")
```

## 4 Optimal Tuning Parameters
***
Plot error rate $(FN+FP)/total$ against lambda, we can find the optimal lambda generate minimum error rate.
```{r}
plot(log10(grid), perf.nodewise$error_1, type="l"
     , xlab = "log10(lambda)", ylab = "error rate"
     , col="blue"
     )
lines(log10(grid), perf.nodewise$error_2, col="red")
lines(log10(grid), perf.glasso$error, col="green")
legend("topright",legend=c("method 1","method 2", "method 3"), col=c("blue","red", "green"), pch="-")

lambda_1 <- grid[which.min(perf.nodewise$error_1)]
lambda_2 <- grid[which.min(perf.nodewise$error_2)]
lambda_3 <- grid[which.min(perf.glasso$error)]

abline(v=log10(lambda_1), col="blue", lty=2)
abline(v=log10(lambda_2), col="red", lty=4)
abline(v=log10(lambda_3), col="green", lty=2)
```


## 5 Mean and Standard Error of Different Approaches
***

```{r}
set.seed(20191109)

start_time <- Sys.time()

auc_1 <- c()
auc_2 <- c()
auc_3 <- c()
min_error_1 <- c()
min_error_2 <- c()
min_error_3 <- c()

t = 1
while (t<=50){
  data <- generate(p, n, delta)
  perf.nodewise <- performance.nodewise.grid(data$X, data$E_true, grid)
  perf.glasso <- performance.glasso.grid(data$X, data$E_true, grid)

  auc_1 <- append(auc_1, perf.nodewise$auc_1)
  auc_2 <- append(auc_2, perf.nodewise$auc_2)
  auc_3 <- append(auc_3, perf.glasso$auc)
  min_error_1 <- append(min_error_1, min(perf.nodewise$error_1))
  min_error_2 <- append(min_error_2, min(perf.nodewise$error_2))
  min_error_3 <- append(min_error_3, min(perf.glasso$error))

  t <- t+1
}

end_time <- Sys.time()
end_time - start_time
```

```{r, results="hold"}
cat("AUC of Method 1\n   mean:           ", mean(auc_1), "\n   standard error: ", sd(auc_1), "\n\n")
cat("AUC of Method 2\n   mean:           ", mean(auc_2), "\n   standard error: ", sd(auc_2), "\n\n")
cat("AUC of Method 3\n   mean:           ", mean(auc_3), "\n   standard error: ", sd(auc_3), "\n\n")

cat("Minimum Error Rate of Method 1\n   mean:           ", mean(min_error_1), "\n   standard error: ", sd(min_error_1), "\n\n")
cat("Minimum Error Rate of Method 2\n   mean:           ", mean(min_error_2), "\n   standard error: ", sd(min_error_2), "\n\n")
cat("Minimum Error Rate of Method 3\n   mean:           ", mean(min_error_3), "\n   standard error: ", sd(min_error_3), "\n\n")
```

```{r, fig.height = 5, fig.width = 7, fig.align = "center"}
par(mfrow=c(1,2))
boxplot(auc_1, auc_2, auc_3)
boxplot(min_error_1, min_error_2, min_error_3)
```
