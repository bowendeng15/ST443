abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
# plot.VaR(yz, Sigma, Mean, start=ymd(20080601), end=ymd(20100601),main="Returns with 1% VaR Limits",ylim=c(-0.2,0.3))
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(GARCH, start=start, end=end, col="red")
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topleft", legend=c("GARCH","t-GARCH","skewed-t-GARCH") col=c("red","blue","darkgreen"))
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(GARCH, start=start, end=end, col="red")
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed-t-GARCH"), col=c("red","blue","darkgreen"))
# plot.VaR(yz, Sigma, Mean, start=ymd(20080601), end=ymd(20100601),main="Returns with 1% VaR Limits",ylim=c(-0.2,0.3))
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(GARCH, start=start, end=end, col="red")
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed-t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
# plot.VaR(yz, Sigma, Mean, start=ymd(20080601), end=ymd(20100601),main="Returns with 1% VaR Limits",ylim=c(-0.2,0.3))
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(GARCH, start=start, end=end, col="red")
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
# plot.VaR(yz, Sigma, Mean, start=ymd(20080601), end=ymd(20100601),main="Returns with 1% VaR Limits",ylim=c(-0.2,0.3))
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(stGARCH, start=start, end=end, col="red")
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(GARCH, start=start, end=end, col="red")
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
plot.VaR(stGARCH11, start=start, end=end, col="red")
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue")
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen")
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = c(-0.2,0.3)
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
ylim = c(-0.2,0.3)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
ylim = c(-0.2,0.28)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
ylim = c(-0.2,0.28)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
start = NULL
end = NULL
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
ylim = c(-0.2,0.28)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
start = ymd(20080601)
end = ymd(20100601)
ylim = NULL
plot.VaR(GARCH, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(tGARCH11, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stGARCH11, start=start, end=end, col="darkgreen", ylim=ylim)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("GARCH","t-GARCH","skewed t-GARCH"), col=c("red","blue","darkgreen"), lty=1)
ylim = c(-0.2,0.28)
plot.VaR(stGARCH11, start=start, end=end, col="red", ylim=ylim)
par(new=T)
plot.VaR(stEWMA, start=start, end=end, col="blue", ylim=ylim)
par(new=T)
plot.VaR(stapARCH, start=start, end=end, col="darkgreen", ylim=ylim)
abline(h=0.05)
abline(h=-0.05)
title(main="Returns with 1% VaR Limits")
legend("topright", legend=c("skewed t-GARCH","skewed t-EWMA","skewed t-APARCH"), col=c("red","blue","darkgreen"), lty=1)
data$PRC[1]/data$PRC[nrow(data)]
data$PRC[nrow(data)] / data$PRC[1]
sp500$PRC[nrow(data)] / sp500$PRC[1]
sp500$spindex[nrow(sp500)] / sp500$spindex[1]
sp500$spindx[nrow(sp500)] / sp500$spindx[1]
basicStats(sp500$sprtrn)
basicStats(y)
basicStats(sp500$sprtrn)
basicStats(y)
basicStats(y)
basicStats(sp500$sprtrn)
show(GARCH110)
spec = ugarchspec(variance.model=list(garchOrder=c(1,5)),mean.model=list(armaOrder=c(0,0)))
GARCH110 = ugarchfit(spec = spec, data = yz, solver="hybrid")
show(GARCH110)
spec = ugarchspec(variance.model=list(garchOrder=c(1,6)),mean.model=list(armaOrder=c(0,0)))
GARCH110 = ugarchfit(spec = spec, data = yz, solver="hybrid")
show(GARCH110)
spec = ugarchspec(variance.model=list(garchOrder=c(1,2)),mean.model=list(armaOrder=c(0,0)))
GARCH110 = ugarchfit(spec = spec, data = yz, solver="hybrid")
GARCH110 = ugarchfit(spec = spec, data = yz, solver="hybrid")
show(GARCH110)
lrtest(tGARCH11, stGARCH11)
#' @title: general performance
perf = function(prob, y, ...){
pred_test <- rep("no", length(y))
pred_test[prob > .5] = "yes"
mat <- table(pred_test, y_test)
cat("\nconfusion matrix----------------------\n")
print( mat )
cat("\naccuracy----------------------\n")
print( mean(pred_test==y_test) )
cat("\nrecall----------------------\n")
print( mat[2,2]/sum(mat[,2]) )
pred_glm <- prediction(prob, y)
cat("\nAUC----------------------\n")
print( performance(pred_glm, "auc")@y.values[[1]] )
#ROC
perf_glm <- performance(pred_glm, measure = "tpr", x.measure = "fpr")
plot(perf_glm, ...)
abline(0, 1, col="grey", lty=2)
}
############################################################################################
###1.READ AND CLEAN DATA
############################################################################################
setwd("/Users/Bowen.Deng/Desktop/LSE/ST443/group_project/ST443/part1")
bank_df<-read.csv("bank-additional-full.csv",sep=";",dec=".")
bank_df$pdays = 1/(1+bank_df$pdays)
# bank_df$pdays[bank_df$pdays==999]=-1  #999 means no previous contact,would make other value useless
bank_df<- bank_df[,which(colnames(bank_df)!= "duration")]
RNGkind(sample.kind = "Rounding")
set.seed(1)
train<- sample(x=dim(bank_df)[1], size=dim(bank_df)[1]*2/3)
#standardize the numerical variables
numBank<- bank_df[,c(1,11:13,15:19)] #numercial column
catBank<- bank_df[,-c(1,11:13,15:19,20)] #categorcial column
scale<-apply(numBank[train,], 2, sd)
center<-apply(numBank[train,], 2, mean)
center["campaign"]<- 1
center["previous"]<- 0
tmp <- scale(numBank,center = center,scale = scale) #scale
tmp <- cbind(tmp, catBank, y=bank_df$y) # bind y
tmp <- model.matrix(y~., data = tmp)[,-1] # design matrix
round(cor(tmp),3)
cor(tmp[,c("loanunknown", "housingunknown")])
## "loanunknown" and " housingunknown " have the exact correlation of 1
bank <- cbind(data.frame(tmp[,which(colnames(tmp)!="loanunknown")]), y=bank_df$y)
## 1. Generate the training and testing datasets
###########################################################
# Create testing and training data set
bank_test = bank[-train,]
bank_train = bank[train,]
# Create testing data for Y
y_test = bank$y[-train]
# resampleing to get data with balanced y
bank_train_yes<- bank_train[bank_train$y=="yes",]
set.seed(2)
resample_idx<- sample(nrow(bank_train_yes),sum(bank_train$y=="no"),replace = T)
bank_train_res<- rbind(bank_train[bank_train$y=="no",],bank_train_yes[resample_idx,]) #resampled training data
## 2.Building logistic model
###########################################################
glm_fit <- glm(y~., data = bank_train, family = "binomial")
prob_test <- predict(glm_fit, bank_test, type = "response")
perf(prob_test, bank_test$y)
#Using resampled dataset
glm_fit_res <- glm(y~., data = bank_train_res, family = "binomial")
prob_test <- predict(glm_fit_res, bank_test, type = "response")
perf(prob_test, bank_test$y)
library(ROCR)
prob_test <- predict(glm_fit, bank_test, type = "response")
perf(prob_test, bank_test$y)
prob_test <- predict(glm_fit_res, bank_test, type = "response")
perf(prob_test, bank_test$y)
## 3. Linear Discriminant Analysis
###########################################################
lda_fit = lda(y~., data = bank_train)
library(MASS)
## 3. Linear Discriminant Analysis
###########################################################
lda_fit = lda(y~., data = bank_train)
prob_test = predict(lda_fit, bank_test)$posterior[,2]
perf(prob_test, bank_test$y)
#Using resampled dataset
lda_fit_res = lda(y~., data = bank_train_res)
prob_test = predict(lda_fit_res, bank_test)$posterior[,2]
perf(prob_test, bank_test$y)
## 4. K-Nearest Neighbors
###########################################################
# Set k=15
knn_pred <- knn(bank_train_res[,-ncol(bank_train_res)], bank_test[,-ncol(bank_test)], bank_train_res$y, k = 15, prob = T)
# Detecting outliers by calculating cook's distance
cooksd<-cooks.distance(glm_fit_res)
# Remove the outliers from the training dataset
tmp <- cbind(bank_train_res,cooksd)
bank_train_df<- tmp[tmp$cooksd< 8/(dim(bank_train_res)[1]-2*53),-dim(tmp)[2]] #exclude the outliers
nrow(bank_train_res)-nrow(bank_train_df)
# 5-fold cross validation for to determine the optimal tuning parameter
# set.seed(2)
# cv.lasso <-cv.glmnet(as.matrix(bank_train_df[,-ncol(bank_train_res)]), bank_train_df$y
#                      , nfolds = 5, family = "binomial", type.measure = "auc")
set.seed(2)
cv.lasso <-cv.glmnet(as.matrix(bank_train_df[,-ncol(bank_train_res)]), bank_train_df$y
, nfolds = 5, family = "binomial", type.measure = "class")
library(glmnet)
library(glmnetUtils)
# 5-fold cross validation for to determine the optimal tuning parameter
set.seed(2)
cv.lasso <-cv.glmnet(as.matrix(bank_train_df[,-ncol(bank_train_res)]), bank_train_df$y
, nfolds = 5, family = "binomial", type.measure = "class")
plot(cv.lasso, ylim=c(0.23, 0.27))
col_lasso = rownames(coef(cv.lasso))[which(coef(cv.lasso)!=0)][-1]
length(col_lasso)
col_lasso = append(col_lasso, "y")
# fit a new LR model
lr_lasso <- glm(y ~ ., data = bank_train_df[,col_lasso], family = "binomial")
prob_test <- predict(lr_lasso, newdata = bank_test[,col_lasso], type = "response")
perf(prob_test, bank_test$y)
##2.Stepwise Selection
###########################################################
## Forward Stepwise Selection by regsubset()
regfit_fwd = regsubsets(y ~ .
, data = bank_train_df
, really.big = T
, nvmax = 51
, method = "forward"
)
library(leaps) # regsubset
##2.Stepwise Selection
###########################################################
## Forward Stepwise Selection by regsubset()
regfit_fwd = regsubsets(y ~ .
, data = bank_train_df
, really.big = T
, nvmax = 51
, method = "forward"
)
set.seed(1)
cv.poly <-cv.glmnet(y ~ .
+ I(age^2)
+ I(campaign^2)
+ I(pdays^2)
+ I(previous^2)
+ I(emp.var.rate^2)
+ I(cons.price.idx^2)
+ I(cons.conf.idx^2)
+ I(euribor3m^2)
+ I(nr.employed^2)
, data = bank_train_df, nfolds = 5
,family = "binomial", type.measure = "class")
plot(cv.poly, ylim=c(0.24, 0.26))
col_poly_lasso = rownames(coef(cv.poly))[which(coef(cv.poly)!=0)][-1]
length(col_poly_lasso)
( formula = paste("y~", paste(col_poly_lasso, collapse = "+") ) )
lr_poly_lasso <- glm(formula, data = bank_train_df, family = "binomial")
prob_test <- predict(lr_poly_lasso, newdata = bank_test, type = "response")
perf(prob_test, bank_test$y, col="red")
plot(cv.poly, ylim=c(0.24, 0.26))
plot(reg_summary$bic, xlab="Number of Variables", ylab="BIC", type="l")
## b) Stepwise Selection
## Forward Stepwise Selection by regsubset()
regfit_fwd = regsubsets(y ~ .
, data = bank_train_df
, really.big = T
, nvmax = 51
, method = "forward"
)
reg_summary = summary(regfit_fwd)
plot(reg_summary$bic, xlab="Number of Variables", ylab="BIC", type="l")
best_model_bic = which.min(reg_summary$bic)
print(best_model_bic)
points(best_model_bic, reg_summary$bic[best_model_bic], col="red", cex=2, pch=20)
points(best_model_bic, reg_summary$bic[best_model_bic], col="red", cex=2, pch=20)
col_fwd = names(coef(regfit_fwd, id=which.min(reg_summary$bic)))[-1]
col_fwd = append(col_fwd, "y")
lr_fwd <- glm(y ~ ., data = bank_train_df[,col_fwd], family = "binomial")
prob_test <- predict(lr_fwd, newdata = bank_test[,col_fwd], type = "response")
perf(prob_test, bank_test$y)
## Backward Stepwise Selection by regsubset()
regfit_bwd = regsubsets(y ~ .
, data = bank_train_df
, really.big = T
, nvmax = 51
, method = "backward"
)
bwd_summary = summary(regfit_bwd)
plot(bwd_summary$bic, xlab="Number of Variables", ylab="BIC", type="l")
best_model_bic_bwd = which.min(bwd_summary$bic)
print(best_model_bic_bwd)#24
points(best_model_bic_bwd, bwd_summary$bic[best_model_bic_bwd], col="red", cex=2, pch=20)
col_bwd = names(coef(regfit_bwd, id=which.min(bwd_summary$bic)))[-1]
col_bwd = append(col_bwd, "y")
lr_bwd <- glm(y ~ ., data = bank_train_df[,col_bwd], family = "binomial")
prob_test <- predict(lr_bwd, newdata = bank_test[,col_bwd], type = "response")
perf(prob_test, bank_test$y)
### 6. Final Model ############################################################
C = summary(lr_poly_lasso)$coefficient
# C[C[,"Pr(>|z|)"]<0.05 & abs(C[,"Estimate"])>0.2, ]
nrow(C)-1
summary(lr_poly_lasso)
setwd("/Users/Bowen.Deng/Desktop/LSE/ST443/group_project/ST443/part2")
source("functions.R") #import own functions
### Data Simulation ########################################################
set.seed(666)
p <- 50 # number of random variables
n <- 500 # number of samples generated
prob <- 0.1 # delta to construct Theta Matrix
data <- generate(p, n, prob)
table(data$E_true)
### Apply Estimation Approaches #################################################
pred.nodewise <- predict.nodewise(data$X, lambda = 0.08)
pred.glasso <- predict.glasso(data$X, lambda = 0.08)
table(pred.nodewise$E_1, data$E_true)
table(pred.nodewise$E_2, data$E_true)
table(pred.glasso$E, data$E_true)
source("functions.R") #import own functions
### Apply Estimation Approaches #################################################
pred.nodewise <- predict.nodewise(data$X, lambda = 0.08)
pred.glasso <- predict.glasso(data$X, lambda = 0.08)
performance(pred.nodewise$E_1, data$E_true)
source("functions.R") #import own functions
performance(pred.nodewise$E_1, data$E_true)
source("functions.R") #import own functions
performance(pred.nodewise$E_1, data$E_true)
(fpr_1 = sum( pred.nodewise$E_1==1 & data$E_true==0 ) / neg)
neg <- sum(data$E_true==0)
pos <- sum(data$E_true==1)
(fpr_1 = sum( pred.nodewise$E_1==1 & data$E_true==0 ) / neg)
(fnr_1 = sum( pred.nodewise$E_1==0 & data$E_true==1 ) / pos)
(error_1 = ( fpr_1*neg+fnr_1*pos )/( neg+pos ))
setwd("/Users/Bowen.Deng/Desktop/LSE/ST443/group_project/ST443/part2")
source("functions.R") #import own functions
performance(pred.nodewise$E_1, data$E_true)
performance(pred.nodewise$E_1, data$E_true)
data$E_true
### Data Simulation ########################################################
set.seed(666)
p <- 50 # number of random variables
n <- 500 # number of samples generated
prob <- 0.1 # delta to construct Theta Matrix
data <- generate(p, n, prob)
table(data$E_true)
### Apply Estimation Approaches #################################################
pred.nodewise <- predict.nodewise(data$X, lambda = 0.08)
pred.glasso <- predict.glasso(data$X, lambda = 0.08)
table(pred.nodewise$E_1, data$E_true)
table(pred.nodewise$E_2, data$E_true)
table(pred.glasso$E, data$E_true)
performance(pred.nodewise$E_1, data$E_true)
performance(pred.nodewise$E_2, data$E_true)
performance(pred.glasso$E, data$E_true)
source("functions.R") #import own functions
### ROC Curve and Overall Performance ###########################################
grid <- 10 ^ seq(-2, -0.8, length = 50)
perf.nodewise <- performance.nodewise.grid(data$X, data$E_true, grid)
perf.nodewise$auc_1 # 0.9941015
perf.nodewise$auc_2 # 0.9953493
source("functions.R") #import own functions
perf.nodewise <- performance.nodewise.grid(data$X, data$E_true, grid)
perf.nodewise$auc_1 # 0.9941015
perf.nodewise$auc_2 # 0.9953493
### Data Simulation ########################################################
set.seed(666)
p <- 50 # number of random variables
n <- 500 # number of samples generated
prob <- 0.1 # delta to construct Theta Matrix
data <- generate(p, n, prob)
table(data$E_true)
### Apply Estimation Approaches #################################################
pred.nodewise <- predict.nodewise(data$X, lambda = 0.08)
pred.glasso <- predict.glasso(data$X, lambda = 0.08)
table(pred.nodewise$E_1, data$E_true)
table(pred.nodewise$E_2, data$E_true)
table(pred.glasso$E, data$E_true)
performance(pred.nodewise$E_1, data$E_true)
performance(pred.nodewise$E_2, data$E_true)
performance(pred.glasso$E, data$E_true)
pred.glasso <- predict.glasso(data$X, lambda = 0.08)
table(pred.glasso$E, data$E_true)
perf.glasso <- performance.glasso.grid(data$X, data$E_true, grid)
perf.glasso$auc # 0.9909053
source("functions.R") #import own functions
perf.glasso <- performance.glasso.grid(data$X, data$E_true, grid)
perf.glasso$auc # 0.9909053
